Index: src/main/java/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java;\n\nimport main.java.core.RaftNode;\nimport main.java.entity.LogEntry;\nimport main.java.network.RaftRequest;\nimport main.java.network.RaftRequestType;\nimport main.java.network.RaftServer;\nimport main.java.util.Config;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n//TIP To <b>Run</b> code, press <shortcut actionId=\"Run\"/> or\n// click the <icon src=\"AllIcons.Actions.Execute\"/> icon in the gutter.\n\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Config config = new Config(\"src/main/resources/config.properties\");\n        List<String> peers = config.getPeers();\n        List<Integer> ports = config.getPorts();\n\n        // 用于存储所有服务器线程的列表\n        List<Thread> serverThreads = new ArrayList<>();\n\n        for (int i = 0; i < peers.size(); i++) {\n            // 创建节点的副本列表\n            List<String> peerSubset = new ArrayList<>(peers);\n            List<Integer> portSubset = new ArrayList<>(ports);\n\n            // 移除当前节点的信息，以便其他节点不尝试与自己连接\n            peerSubset.remove(i);\n            portSubset.remove(i);\n\n            // 创建每个节点\n            RaftNode raftNode = new RaftNode(i + 1, peerSubset, portSubset);\n            if (i == 0){\n                LogEntry l1 = new LogEntry(1,0,\"add 1\");\n                LogEntry l2 = new LogEntry(1,0,\"update 2\");\n                LogEntry l3 = new LogEntry(1,0,\"delete 2\");\n                List<LogEntry> param = new ArrayList<>();\n                param.add(l1);\n                param.add(l2);\n                param.add(l3);\n                RaftRequest t = new RaftRequest(\n                        RaftRequestType.SYNC,\n                        0,\n                        0,\n                        0,\n                        0,\n                        param,\n                        0,\n                        false\n                );\n                raftNode.sync(t);\n            }\n            // 创建并启动服务器线程\n            RaftServer server = new RaftServer(ports.get(i), raftNode);\n            Thread serverThread = new Thread(server, \"ServerThread-\" + (i + 1));\n            serverThread.start();  // 启动线程\n\n            // 将线程添加到列表中\n            serverThreads.add(serverThread);\n        }\n\n        // 等待所有线程完成\n        for (Thread thread : serverThreads) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                System.err.println(\"Server thread interrupted: \" + e.getMessage());\n                Thread.currentThread().interrupt(); // 重新设置中断状态\n            }\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Main.java b/src/main/java/Main.java
--- a/src/main/java/Main.java	
+++ b/src/main/java/Main.java	
@@ -35,26 +35,26 @@
 
             // 创建每个节点
             RaftNode raftNode = new RaftNode(i + 1, peerSubset, portSubset);
-            if (i == 0){
-                LogEntry l1 = new LogEntry(1,0,"add 1");
-                LogEntry l2 = new LogEntry(1,0,"update 2");
-                LogEntry l3 = new LogEntry(1,0,"delete 2");
-                List<LogEntry> param = new ArrayList<>();
-                param.add(l1);
-                param.add(l2);
-                param.add(l3);
-                RaftRequest t = new RaftRequest(
-                        RaftRequestType.SYNC,
-                        0,
-                        0,
-                        0,
-                        0,
-                        param,
-                        0,
-                        false
-                );
-                raftNode.sync(t);
-            }
+//            if (i == 0){
+//                LogEntry l1 = new LogEntry(1,0,"add 1");
+//                LogEntry l2 = new LogEntry(1,0,"update 2");
+//                LogEntry l3 = new LogEntry(1,0,"delete 2");
+//                List<LogEntry> param = new ArrayList<>();
+//                param.add(l1);
+//                param.add(l2);
+//                param.add(l3);
+//                RaftRequest t = new RaftRequest(
+//                        RaftRequestType.SYNC,
+//                        0,
+//                        0,
+//                        0,
+//                        0,
+//                        param,
+//                        0,
+//                        false
+//                );
+//                raftNode.sync(t);
+//            }
             // 创建并启动服务器线程
             RaftServer server = new RaftServer(ports.get(i), raftNode);
             Thread serverThread = new Thread(server, "ServerThread-" + (i + 1));
Index: src/main/java/core/RaftNode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.core;\n\nimport main.java.entity.LogEntry;\nimport main.java.entity.RaftState;\nimport main.java.network.RaftClient;\nimport main.java.network.RaftRequest;\nimport main.java.network.RaftRequestType;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RaftNode {\n    private RaftState state;\n    private ServerState role; // LEADER, FOLLOWER, CANDIDATE\n    private Timer electionTimer;\n    private Timer heartbeatTimer;\n    private Random random;\n    private int nodeId; // 节点的唯一标识\n    private AtomicInteger voteCount; // 用于计票的原子整数\n    private AtomicInteger successCount; // 用于日志复制的原子整数\n    private List<String> peers; // 其他节点的地址列表\n    private List<Integer> port; // 其他节点的地址列表\n    private RaftClient raftClient; // 网络通信客户端\n    public RaftNode(int nodeId,List<String> peers,List<Integer> port) {\n        this.state = new RaftState();\n        this.role = ServerState.FOLLOWER;\n        this.electionTimer = new Timer();\n        this.random = new Random();\n        this.nodeId = nodeId;\n        this.voteCount = new AtomicInteger(0);\n        this.successCount = new AtomicInteger(0);\n        this.raftClient = new RaftClient();\n        this.peers = peers;\n        this.port = port;\n        resetElectionTimer();\n    }\n\n    private void resetElectionTimer() {\n        if (electionTimer != null) {\n            electionTimer.cancel();\n        }\n        electionTimer = new Timer();\n        electionTimer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                startElection();\n            }\n        }, 2500 + random.nextInt(2500)); // 1500 to 3000 milliseconds\n    }\n\n    public synchronized void startElection() {\n        state.setCurrentTerm(state.getCurrentTerm() + 1);\n        System.out.println(\"node \"+nodeId +\" term \"+state.getCurrentTerm()+\" starts to elect a leader\");\n        state.setVotedFor(nodeId);\n        role = ServerState.CANDIDATE;\n        voteCount.set(1);  // 为自己投票\n\n        // 发送请求投票到所有其他节点\n        for (int i = 0;i < peers.size(); i++) {\n            RaftRequest voteRequest = new RaftRequest(\n                    RaftRequestType.REQUEST_VOTE,\n                    state.getCurrentTerm(),\n                    nodeId,\n                    state.getLastLogIndex(),\n                    state.getLastLogTerm(),\n                    state.getLog(),\n                    state.getCommitIndex(),\n                    false\n            );\n            raftClient.sendRequest(peers.get(i),port.get(i), voteRequest);\n        }\n\n        // 重新设置选举定时器\n        resetElectionTimer();\n    }\n\n    //接收投票请求，发送决议票到候选人\n    public void receiveVoteRequest(RaftRequest request) {\n        System.out.println(\"node \"+nodeId+\" term \"+state.getCurrentTerm()+\" gets vote request from candidate node \" + request.getCandidateId());\n        boolean voteGranted = false;\n        int currentTerm = state.getCurrentTerm();\n        int lastLogIndex = state.getLastLogIndex();\n        int lastLogTerm = state.getLastLogTerm();\n\n        if (request.getTerm() < currentTerm) {\n            voteGranted = false; // 如果请求的任期小于当前任期，拒绝投票\n        } else {\n            if (request.getTerm() > currentTerm){\n                state.setCurrentTerm(request.getTerm());\n                state.setVotedFor(-1);\n            }\n            if (state.getVotedFor() == -1){\n                state.setVotedFor(request.getCandidateId());\n                voteGranted = true;\n                resetElectionTimer();\n            }\n//            if (request.getTerm() > currentTerm || state.getVotedFor() == -1) {\n//                state.setCurrentTerm(request.getTerm()); // 更新当前任期\n//                state.setVotedFor(-1);  // 重置已投票的候选人ID\n//\n//                if (request.getLastLogTerm() > lastLogTerm ||\n//                        (request.getLastLogTerm() == lastLogTerm && request.getLastLogIndex() >= lastLogIndex)) {\n//                    state.setVotedFor(request.getCandidateId()); // 投票给候选人\n//                    voteGranted = true; // 发送赞成票\n//                }\n//            }\n        }\n\n        // 使用 RaftClient 发送投票结果\n        RaftRequest voteResponse = new RaftRequest(\n                RaftRequestType.ANSWER_VOTE,\n                state.getCurrentTerm(),\n                nodeId,\n                state.getLastLogIndex(),\n                state.getLastLogTerm(),\n                state.getLog(),\n                state.getCommitIndex(),\n                voteGranted\n        );\n        int id = request.getCandidateId();\n        System.out.println(\"node \"+nodeId+\" term \"+state.getCurrentTerm()+\" decides to send a \" + voteGranted + \" to \" + id);\n        raftClient.sendRequest(peers.get(id-1),port.get(id-1),voteResponse);\n    }\n\n    //接收决议票\n    public void receiveVoteResponse(RaftRequest request) {\n        boolean voteGranted = request.getVote();\n        System.out.println(\"candidate \"+nodeId+\" term \"+state.getCurrentTerm()+\" receives \"+voteGranted+\" vote from follower node \"+request.getCandidateId());\n        if (voteGranted) {\n            int votes = voteCount.incrementAndGet();\n//            System.out.println(\"node \"+nodeId+\" vote number: \" + votes);\n            if (votes >= (peers.size() / 2) + 1) {\n                role = ServerState.LEADER;\n                System.out.println(\"node \"+nodeId+\" term \"+state.getCurrentTerm()+\" became leader for term \" + state.getCurrentTerm());\n                voteCount.set(0);\n                // 开始领导者的行为，如定期发送心跳\n                if (electionTimer != null) {\n                    electionTimer.cancel();\n                    electionTimer = null; // 取消后将计时器置空\n                }\n                heartbeatTimer = new Timer();\n                heartbeatTimer.scheduleAtFixedRate(new TimerTask() {\n                    @Override\n                    public void run() {\n                        sendHeartbeats();\n                    }\n                }, 0, 500);  // 每500毫秒发送一次心跳\n                // 还可以在此处初始化其他与领导者相关的任务\n            }\n        }\n    }\n\n    //发送心跳\n    public void sendHeartbeats() {\n        successCount.set(0);\n        if (role == ServerState.LEADER) {\n            for (int i = 0;i < peers.size(); i++) {\n                RaftRequest heartbeat = new RaftRequest(\n                        RaftRequestType.SEND_HEARTBEAT,\n                        state.getCurrentTerm(),\n                        nodeId,\n                        state.getLastLogIndex(),\n                        state.getLastLogTerm(),\n                        null,\n                        state.getCommitIndex(),\n                        false\n                );\n                raftClient.sendRequest(peers.get(i),port.get(i), heartbeat);\n            }\n        }\n    }\n\n    //接收心跳\n    public synchronized void receiveHeartbeats(RaftRequest request){\n        System.out.println(nodeId+\" receives a heartbeat from \" + request.getCandidateId());\n        //leader的term小于follwer，拒绝\n        if (request.getTerm() < state.getCurrentTerm()) return;\n\n        //leader的term大于follwer，更新follwer的term和role,重置选举计时\n        state.setCurrentTerm(request.getTerm());\n        role = ServerState.FOLLOWER;\n        resetElectionTimer();\n        if(request.getEntries() == null) return;\n\n        //判断日志复制是否成功\n        boolean isSuccess;\n        int leaderLastLogIndex = request.getLastLogIndex();\n        int leaderLastLogTerm = request.getLastLogTerm();\n\n        //判断末条日志是否相同\n        if(leaderLastLogIndex == state.getLastLogIndex() && leaderLastLogTerm == state.getTermFromIndex(leaderLastLogIndex)){\n            isSuccess = true;\n            state.addAll(request.getEntries());\n            //提交进度比leader慢\n            if (state.getCommitIndex() < request.getLeaderCommit()){\n                //apply to state machine\n            }\n        }\n        else{\n            isSuccess = false;\n        }\n\n        int leaderId = request.getCandidateId();\n        RaftRequest heartbeatResponse = new RaftRequest(\n                RaftRequestType.ANSWER_HEARTBEAT,\n                state.getCurrentTerm(),\n                nodeId,\n                state.getLastLogIndex(),\n                state.getLastLogTerm(),\n                null,\n                state.getCommitIndex(),\n                isSuccess\n        );\n        raftClient.sendRequest(peers.get(leaderId-1),port.get(leaderId-1),heartbeatResponse);\n\n    }\n\n    //接收心跳结果\n    public void receiveHeartbeatsResult(RaftRequest request){\n        boolean isSuccess = request.getVote();\n        System.out.println(\"leader \"+nodeId+\" term \"+state.getCurrentTerm()+\" receives success from follower node \"+request.getCandidateId());\n        if (isSuccess) {\n            int sc = successCount.incrementAndGet();\n            if (sc >= (peers.size() / 2) + 1) {\n                successCount.set(0);\n                //apply to state machine\n            }\n        }\n        else {\n            int followerId = request.getCandidateId();\n            RaftRequest heartbeat = new RaftRequest(\n                    RaftRequestType.SYNC,\n                    state.getCurrentTerm(),\n                    nodeId,\n                    state.getLastLogIndex(),\n                    state.getLastLogTerm(),\n                    state.getLog(),\n                    state.getCommitIndex(),\n                    false\n            );\n            raftClient.sendRequest(peers.get(followerId-1),port.get(followerId-1), heartbeat);\n        }\n    }\n\n    public void sync(RaftRequest request) {\n        state.setLog(request.getEntries());\n        System.out.println(\"node \"+nodeId+\" sync :\"+state.getLog());\n    }\n\n//    public void appendEntries(List<LogEntry> entries) {\n//        // 实现日志条目追加逻辑\n//        if (entries.isEmpty()) {\n//            // 处理心跳\n//            System.out.println(\"Received heartbeat from leader\");\n//            resetElectionTimer();\n//        } else {\n//            // 处理追加日志条目\n//            // 这里需要实现日志追加的逻辑\n//            System.out.println(\"Received log entries to append\");\n//        }\n//    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/core/RaftNode.java b/src/main/java/core/RaftNode.java
--- a/src/main/java/core/RaftNode.java	
+++ b/src/main/java/core/RaftNode.java	
@@ -45,7 +45,7 @@
             public void run() {
                 startElection();
             }
-        }, 2500 + random.nextInt(2500)); // 1500 to 3000 milliseconds
+        }, 5000 + random.nextInt(2500)); // 1500 to 3000 milliseconds
     }
 
     public synchronized void startElection() {
@@ -144,7 +144,7 @@
                     public void run() {
                         sendHeartbeats();
                     }
-                }, 0, 500);  // 每500毫秒发送一次心跳
+                }, 0, 5000);  // 每500毫秒发送一次心跳
                 // 还可以在此处初始化其他与领导者相关的任务
             }
         }
Index: src/main/java/server2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/server2.java b/src/main/java/server2.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/server2.java	
@@ -0,0 +1,77 @@
+package main.java;
+
+import main.java.core.RaftNode;
+import main.java.entity.LogEntry;
+import main.java.network.RaftRequest;
+import main.java.network.RaftRequestType;
+import main.java.network.RaftServer;
+import main.java.util.Config;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+//TIP To <b>Run</b> code, press <shortcut actionId="Run"/> or
+// click the <icon src="AllIcons.Actions.Execute"/> icon in the gutter.
+
+
+public class server2 {
+    public static void main(String[] args) throws IOException {
+        Config config = new Config("src/main/resources/config.properties");
+        List<String> peers = config.getPeers();
+        List<Integer> ports = config.getPorts();
+
+        // 用于存储所有服务器线程的列表
+        List<Thread> serverThreads = new ArrayList<>();
+
+        for (int i = 1; i < 2; i++) {
+            // 创建节点的副本列表
+            List<String> peerSubset = new ArrayList<>(peers);
+            List<Integer> portSubset = new ArrayList<>(ports);
+
+            // 移除当前节点的信息，以便其他节点不尝试与自己连接
+            peerSubset.remove(i);
+            portSubset.remove(i);
+
+            // 创建每个节点
+            RaftNode raftNode = new RaftNode(i + 1, peerSubset, portSubset);
+            if (i == 0){
+                LogEntry l1 = new LogEntry(1,0,"add 1");
+                LogEntry l2 = new LogEntry(1,0,"update 2");
+                LogEntry l3 = new LogEntry(1,0,"delete 2");
+                List<LogEntry> param = new ArrayList<>();
+                param.add(l1);
+                param.add(l2);
+                param.add(l3);
+                RaftRequest t = new RaftRequest(
+                        RaftRequestType.SYNC,
+                        0,
+                        0,
+                        0,
+                        0,
+                        param,
+                        0,
+                        false
+                );
+                raftNode.sync(t);
+            }
+            // 创建并启动服务器线程
+            RaftServer server = new RaftServer(ports.get(i), raftNode);
+            Thread serverThread = new Thread(server, "ServerThread-" + (i + 1));
+            serverThread.start();  // 启动线程
+
+            // 将线程添加到列表中
+            serverThreads.add(serverThread);
+        }
+
+        // 等待所有线程完成
+        for (Thread thread : serverThreads) {
+            try {
+                thread.join();
+            } catch (InterruptedException e) {
+                System.err.println("Server thread interrupted: " + e.getMessage());
+                Thread.currentThread().interrupt(); // 重新设置中断状态
+            }
+        }
+    }
+}
Index: src/main/java/server3.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/server3.java b/src/main/java/server3.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/server3.java	
@@ -0,0 +1,77 @@
+package main.java;
+
+import main.java.core.RaftNode;
+import main.java.entity.LogEntry;
+import main.java.network.RaftRequest;
+import main.java.network.RaftRequestType;
+import main.java.network.RaftServer;
+import main.java.util.Config;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+//TIP To <b>Run</b> code, press <shortcut actionId="Run"/> or
+// click the <icon src="AllIcons.Actions.Execute"/> icon in the gutter.
+
+
+public class server3 {
+    public static void main(String[] args) throws IOException {
+        Config config = new Config("src/main/resources/config.properties");
+        List<String> peers = config.getPeers();
+        List<Integer> ports = config.getPorts();
+
+        // 用于存储所有服务器线程的列表
+        List<Thread> serverThreads = new ArrayList<>();
+
+        for (int i = 2; i < peers.size(); i++) {
+            // 创建节点的副本列表
+            List<String> peerSubset = new ArrayList<>(peers);
+            List<Integer> portSubset = new ArrayList<>(ports);
+
+            // 移除当前节点的信息，以便其他节点不尝试与自己连接
+            peerSubset.remove(i);
+            portSubset.remove(i);
+
+            // 创建每个节点
+            RaftNode raftNode = new RaftNode(i + 1, peerSubset, portSubset);
+            if (i == 0){
+                LogEntry l1 = new LogEntry(1,0,"add 1");
+                LogEntry l2 = new LogEntry(1,0,"update 2");
+                LogEntry l3 = new LogEntry(1,0,"delete 2");
+                List<LogEntry> param = new ArrayList<>();
+                param.add(l1);
+                param.add(l2);
+                param.add(l3);
+                RaftRequest t = new RaftRequest(
+                        RaftRequestType.SYNC,
+                        0,
+                        0,
+                        0,
+                        0,
+                        param,
+                        0,
+                        false
+                );
+                raftNode.sync(t);
+            }
+            // 创建并启动服务器线程
+            RaftServer server = new RaftServer(ports.get(i), raftNode);
+            Thread serverThread = new Thread(server, "ServerThread-" + (i + 1));
+            serverThread.start();  // 启动线程
+
+            // 将线程添加到列表中
+            serverThreads.add(serverThread);
+        }
+
+        // 等待所有线程完成
+        for (Thread thread : serverThreads) {
+            try {
+                thread.join();
+            } catch (InterruptedException e) {
+                System.err.println("Server thread interrupted: " + e.getMessage());
+                Thread.currentThread().interrupt(); // 重新设置中断状态
+            }
+        }
+    }
+}
Index: src/main/java/server1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/server1.java b/src/main/java/server1.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/server1.java	
@@ -0,0 +1,77 @@
+package main.java;
+
+import main.java.core.RaftNode;
+import main.java.entity.LogEntry;
+import main.java.network.RaftRequest;
+import main.java.network.RaftRequestType;
+import main.java.network.RaftServer;
+import main.java.util.Config;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+//TIP To <b>Run</b> code, press <shortcut actionId="Run"/> or
+// click the <icon src="AllIcons.Actions.Execute"/> icon in the gutter.
+
+
+public class server1 {
+    public static void main(String[] args) throws IOException {
+        Config config = new Config("src/main/resources/config.properties");
+        List<String> peers = config.getPeers();
+        List<Integer> ports = config.getPorts();
+
+        // 用于存储所有服务器线程的列表
+        List<Thread> serverThreads = new ArrayList<>();
+
+        for (int i = 0; i < 1; i++) {
+            // 创建节点的副本列表
+            List<String> peerSubset = new ArrayList<>(peers);
+            List<Integer> portSubset = new ArrayList<>(ports);
+
+            // 移除当前节点的信息，以便其他节点不尝试与自己连接
+            peerSubset.remove(i);
+            portSubset.remove(i);
+
+            // 创建每个节点
+            RaftNode raftNode = new RaftNode(i + 1, peerSubset, portSubset);
+            if (i == 0){
+                LogEntry l1 = new LogEntry(1,0,"add 1");
+                LogEntry l2 = new LogEntry(1,0,"update 2");
+                LogEntry l3 = new LogEntry(1,0,"delete 2");
+                List<LogEntry> param = new ArrayList<>();
+                param.add(l1);
+                param.add(l2);
+                param.add(l3);
+                RaftRequest t = new RaftRequest(
+                        RaftRequestType.SYNC,
+                        0,
+                        0,
+                        0,
+                        0,
+                        param,
+                        0,
+                        false
+                );
+                raftNode.sync(t);
+            }
+            // 创建并启动服务器线程
+            RaftServer server = new RaftServer(ports.get(i), raftNode);
+            Thread serverThread = new Thread(server, "ServerThread-" + (i + 1));
+            serverThread.start();  // 启动线程
+
+            // 将线程添加到列表中
+            serverThreads.add(serverThread);
+        }
+
+        // 等待所有线程完成
+        for (Thread thread : serverThreads) {
+            try {
+                thread.join();
+            } catch (InterruptedException e) {
+                System.err.println("Server thread interrupted: " + e.getMessage());
+                Thread.currentThread().interrupt(); // 重新设置中断状态
+            }
+        }
+    }
+}
